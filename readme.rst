
clarify the type/container/item/whatis stuff
container is a sequence, item is a single value
an element is a member of a configuration container
can be either of those or another configuration container
key is a string that references an element

that _validate_set thing could get removed from the class, if that's useful to
enforce interface

try again with sphinx.. create the configng.rst with code. possibly the sphinx-apidoc command is superfluous
import the package then api, and recurse through their symbols. should be straightforward enough.
just grab stuff that has docstrings and isn't a member of the parent class
oh, but whats inherited and whats overriden??

sphinx-apidoc -o doc -F -A "Chris Fuller" -H ConfigNG -V 0.8 -R 0.8 .

make some sphinx notes..
sphinx-apidoc template
the autodoc-skip-member stuff...
cut out a lot of conf.py
nuke make.bat
the magic of make_rst.py, which needs a better name!
that validator table


MOTIVATION
==========

This is a thorough refactoring of a simple configuration system I wrote many
years ago, before the CheeseShop/PyPI or a lot of third-party libraries. It was
meeting my needs well, for the most part, but lacked some features and needed a
code cleanup. Still, it was firmly in the "if it ain't broke, don't fix it"
category for a very long time. Well, no longer!

The winoze INI format was unsatisfying. There wasn't a lot else to choose from
at the time, except perhaps some full-blown parsers, which were overkill.

I wanted subsections, type checking and conversion, distribution among many
files and directories via an include system, and structure defined in the con-
figuration, rather than in the code. A dictionary interface was desired, but
was less important.

I did not need serialization/write support, advanced parsing features, or a lot
of extensibility. I was writing a basic system for my own use.

Even now, there are some generalizations that would be reaonsably straight-
forward to add, but I'm giving them a pass. Simplicity wins versus features I
don't plan to use. Unless it's additional container types. I would have been
happy with lists for everything. I guess I got a little out of hand!


SUMMARY
=======

containers are all lists until they are out of scope. then a new container of
the intended type is constructed from the list. this is necessary to support
immutable containers, but it means no complaining about unhashable set elements
or other incompatible elements until the end.

Concepts
--------

immutable
(configuration) container/tree
item
type
declared
defined
command
(un)ordered
validate/convert


children are defined by a command, %dict or %odict. they maybe inline or
external. an inline child begins with an open brace at the end of the line
started by the dict or odict, and ends with a close brace on a line by itself.
an externally defined child has a filename to load, as though included.


Tips and Tricks
---------------
Containers can't contain containers, but items may be anything your custom validator can parse.

Containers with mixed type elements are possible, but a custom type is needed
that can validate them all. obviously, one needs to conform to the rules of the
underlying container. for instance, all elements of a set must be hashable.

replacing types is allowed, but existing references to the previous type will persist,
unless it's refetched at every call, or some explicit updating mechanism is included.

Enforced limitations
--------------------

not a class interface. all customizations are global.

requires Python 2.7

three-space indents!

no containers in containers

TODO
====

do_string is an external dependency!

make_grid is, too.

unit tests
test lists of dictionaries
test multiline items
use parser on a stream
added untyped items

what about using a nice autogenerated parser?
